{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _empty, empty_fn, _fire, fire_fn, _move, move_fn, _prepLoop, prepLoop_fn, _fireItemWithContext, fireItemWithContext_fn, _wait, wait_fn, _attachCursor, attachCursor_fn, _elementIsInput, elementIsInput_fn, _queueAndReturn, queueAndReturn_fn, _maybeAppendPause, maybeAppendPause_fn, _generateTemporaryOptionQueueItems, generateTemporaryOptionQueueItems_fn, _updateOptions, updateOptions_fn, _generateQueue, generateQueue_fn, _buildOptions, _prependHardcodedStrings, prependHardcodedStrings_fn, _setUpCursor, setUpCursor_fn, _addSplitPause, addSplitPause_fn, _type, type_fn, _delete, delete_fn, _removeNode, removeNode_fn, _getPace, getPace_fn, _derivedCursorPosition, derivedCursorPosition_get, _isInput, isInput_get, _shouldRenderCursor, shouldRenderCursor_get, _allChars, allChars_get, _a;\nimport React, { forwardRef, useRef, useState, useEffect } from \"react\";\nconst isArray = thing => Array.isArray(thing);\nconst asArray = value => isArray(value) ? value : [value];\nlet Queue = function (initialItems) {\n  let add = function (steps) {\n    asArray(steps).forEach(step => {\n      var _a2;\n      return _q.set(Symbol((_a2 = step.char) == null ? void 0 : _a2.innerText), buildQueueItem({\n        ...step\n      }));\n    });\n    return this;\n  };\n  let getTypeable = () => rawValues().filter(value => value.typeable);\n  let set = function (index, item) {\n    let keys = [..._q.keys()];\n    _q.set(keys[index], buildQueueItem(item));\n  };\n  let buildQueueItem = queueItem => {\n    queueItem.shouldPauseCursor = function () {\n      return Boolean(this.typeable || this.cursorable || this.deletable);\n    };\n    return queueItem;\n  };\n  let reset = function () {\n    _q.forEach(item => delete item.done);\n  };\n  let wipe = function () {\n    _q = /* @__PURE__ */new Map();\n    add(initialItems);\n  };\n  let getQueue = () => _q;\n  let rawValues = () => Array.from(_q.values());\n  let destroy = key => _q.delete(key);\n  let getItems = (all = false) => all ? rawValues() : rawValues().filter(i => !i.done);\n  let done = (key, shouldDestroy = false) => shouldDestroy ? _q.delete(key) : _q.get(key).done = true;\n  let _q = /* @__PURE__ */new Map();\n  add(initialItems);\n  return {\n    add,\n    set,\n    wipe,\n    done,\n    reset,\n    destroy,\n    getItems,\n    getQueue,\n    getTypeable\n  };\n};\nconst DATA_ATTRIBUTE = \"data-typeit-id\";\nconst CURSOR_CLASS = \"ti-cursor\";\nconst END = \"END\";\nconst DEFAULT_STATUSES = {\n  started: false,\n  completed: false,\n  frozen: false,\n  destroyed: false\n};\nconst DEFAULT_OPTIONS = {\n  breakLines: true,\n  cursor: {\n    autoPause: true,\n    autoPauseDelay: 500,\n    animation: {\n      frames: [0, 0, 1].map(n => {\n        return {\n          opacity: n\n        };\n      }),\n      options: {\n        iterations: Infinity,\n        easing: \"steps(2, start)\",\n        fill: \"forwards\"\n      }\n    }\n  },\n  cursorChar: \"|\",\n  cursorSpeed: 1e3,\n  deleteSpeed: null,\n  html: true,\n  lifeLike: true,\n  loop: false,\n  loopDelay: 750,\n  nextStringDelay: 750,\n  speed: 100,\n  startDelay: 250,\n  startDelete: false,\n  strings: [],\n  waitUntilVisible: false,\n  beforeString: () => {},\n  afterString: () => {},\n  beforeStep: () => {},\n  afterStep: () => {},\n  afterComplete: () => {}\n};\nconst PLACEHOLDER_CSS = `[${DATA_ATTRIBUTE}]:before {content: '.'; display: inline-block; width: 0; visibility: hidden;}`;\nconst createElement = el => document.createElement(el);\nconst createTextNode = content => document.createTextNode(content);\nconst appendStyleBlock = (styles, id = \"\") => {\n  let styleBlock = createElement(\"style\");\n  styleBlock.id = id;\n  styleBlock.appendChild(createTextNode(styles));\n  document.head.appendChild(styleBlock);\n};\nconst calculateDelay = delayArg => {\n  if (!isArray(delayArg)) {\n    delayArg = [delayArg / 2, delayArg / 2];\n  }\n  return delayArg;\n};\nconst randomInRange = (value, range2) => {\n  return Math.abs(Math.random() * (value + range2 - (value - range2)) + (value - range2));\n};\nlet range = val => val / 2;\nfunction calculatePace(options) {\n  let {\n    speed,\n    deleteSpeed,\n    lifeLike\n  } = options;\n  deleteSpeed = deleteSpeed !== null ? deleteSpeed : speed / 3;\n  return lifeLike ? [randomInRange(speed, range(speed)), randomInRange(deleteSpeed, range(deleteSpeed))] : [speed, deleteSpeed];\n}\nconst toArray = val => Array.from(val);\nlet expandTextNodes = element => {\n  [...element.childNodes].forEach(child => {\n    if (child.nodeValue) {\n      [...child.nodeValue].forEach(c => {\n        child.parentNode.insertBefore(createTextNode(c), child);\n      });\n      child.remove();\n      return;\n    }\n    expandTextNodes(child);\n  });\n  return element;\n};\nconst getParsedBody = content => {\n  let doc = document.implementation.createHTMLDocument();\n  doc.body.innerHTML = content;\n  return expandTextNodes(doc.body);\n};\nfunction walkElementNodes(element, shouldReverse = false, shouldIncludeCursor = false) {\n  let cursor = element.querySelector(`.${CURSOR_CLASS}`);\n  let walker = document.createTreeWalker(element, NodeFilter.SHOW_ALL, {\n    acceptNode: node => {\n      var _a2, _b;\n      if (cursor && shouldIncludeCursor) {\n        if ((_a2 = node.classList) == null ? void 0 : _a2.contains(CURSOR_CLASS)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n        if (cursor.contains(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n      return ((_b = node.classList) == null ? void 0 : _b.contains(CURSOR_CLASS)) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;\n    }\n  });\n  let nextNode;\n  let nodes = [];\n  while (nextNode = walker.nextNode()) {\n    if (!nextNode.originalParent) {\n      nextNode.originalParent = nextNode.parentNode;\n    }\n    nodes.push(nextNode);\n  }\n  return shouldReverse ? nodes.reverse() : nodes;\n}\nfunction chunkStringAsHtml(string) {\n  return walkElementNodes(getParsedBody(string));\n}\nfunction maybeChunkStringAsHtml(str, asHtml = true) {\n  return asHtml ? chunkStringAsHtml(str) : toArray(str).map(createTextNode);\n}\nconst isNumber = value => Number.isInteger(value);\nconst countStepsToSelector = ({\n  queueItems,\n  selector,\n  cursorPosition,\n  to\n}) => {\n  if (isNumber(selector)) {\n    return selector * -1;\n  }\n  let isMovingToEnd = new RegExp(END, \"i\").test(to);\n  let selectorIndex = selector ? [...queueItems].reverse().findIndex(({\n    char\n  }) => {\n    let parentElement = char.parentElement;\n    let parentMatches = parentElement.matches(selector);\n    if (isMovingToEnd && parentMatches) {\n      return true;\n    }\n    return parentMatches && parentElement.firstChild.isSameNode(char);\n  }) : -1;\n  if (selectorIndex < 0) {\n    selectorIndex = isMovingToEnd ? 0 : queueItems.length - 1;\n  }\n  let offset = isMovingToEnd ? 0 : 1;\n  return selectorIndex - cursorPosition + offset;\n};\nconst destroyTimeouts = timeouts => {\n  timeouts.forEach(clearTimeout);\n  return [];\n};\nconst duplicate = (value, times) => new Array(times).fill(value);\nlet beforePaint = cb => {\n  return new Promise(resolve => {\n    requestAnimationFrame(async () => {\n      resolve(await cb());\n    });\n  });\n};\nlet getAnimationFromElement = element => {\n  return element == null ? void 0 : element.getAnimations().find(animation => {\n    return animation.id === element.dataset.tiAnimationId;\n  });\n};\nlet setCursorAnimation = ({\n  cursor,\n  frames,\n  options\n}) => {\n  let animation = cursor.animate(frames, options);\n  animation.pause();\n  animation.id = cursor.dataset.tiAnimationId;\n  beforePaint(() => {\n    beforePaint(() => {\n      animation.play();\n    });\n  });\n  return animation;\n};\nlet rebuildCursorAnimation = ({\n  cursor,\n  options,\n  cursorOptions\n}) => {\n  if (!cursor || !cursorOptions) return;\n  let animation = getAnimationFromElement(cursor);\n  let oldCurrentTime;\n  if (animation) {\n    options.delay = animation.effect.getComputedTiming().delay;\n    oldCurrentTime = animation.currentTime;\n    animation.cancel();\n  }\n  let newAnimation = setCursorAnimation({\n    cursor,\n    frames: cursorOptions.animation.frames,\n    options\n  });\n  if (oldCurrentTime) {\n    newAnimation.currentTime = oldCurrentTime;\n  }\n  return newAnimation;\n};\nlet execute = queueItem => {\n  var _a2;\n  return (_a2 = queueItem.func) == null ? void 0 : _a2.call(null);\n};\nlet fireItem = async ({\n  index,\n  queueItems,\n  wait: wait2,\n  cursor,\n  cursorOptions\n}) => {\n  let queueItem = queueItems[index][1];\n  let instantQueue = [];\n  let tempIndex = index;\n  let futureItem = queueItem;\n  let shouldBeGrouped = () => futureItem && !futureItem.delay;\n  let shouldPauseCursor = queueItem.shouldPauseCursor() && cursorOptions.autoPause;\n  while (shouldBeGrouped()) {\n    instantQueue.push(futureItem);\n    shouldBeGrouped() && tempIndex++;\n    futureItem = queueItems[tempIndex] ? queueItems[tempIndex][1] : null;\n  }\n  if (instantQueue.length) {\n    await beforePaint(async () => {\n      for (let q of instantQueue) {\n        await execute(q);\n      }\n    });\n    return tempIndex - 1;\n  }\n  let animation = getAnimationFromElement(cursor);\n  let options;\n  if (animation) {\n    options = {\n      ...animation.effect.getComputedTiming(),\n      delay: shouldPauseCursor ? cursorOptions.autoPauseDelay : 0\n    };\n  }\n  await wait2(async () => {\n    if (animation && shouldPauseCursor) {\n      animation.cancel();\n    }\n    await beforePaint(() => {\n      execute(queueItem);\n    });\n  }, queueItem.delay);\n  await rebuildCursorAnimation({\n    cursor,\n    options,\n    cursorOptions\n  });\n  return index;\n};\nconst fireWhenVisible = (element, func) => {\n  let observer = new IntersectionObserver((entries, observer2) => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        func();\n        observer2.unobserve(element);\n      }\n    });\n  }, {\n    threshold: 1\n  });\n  observer.observe(element);\n};\nconst generateHash = () => Math.random().toString().substring(2, 9);\nconst isInput = el => {\n  return \"value\" in el;\n};\nlet getAllChars = element => {\n  if (isInput(element)) {\n    return toArray(element.value);\n  }\n  return walkElementNodes(element, true).filter(c => !(c.childNodes.length > 0));\n};\nlet handleFunctionalArg = arg => {\n  return typeof arg === \"function\" ? arg() : arg;\n};\nlet select = (selector, element = document, all = false) => {\n  return element[`querySelector${all ? \"All\" : \"\"}`](selector);\n};\nlet isBodyElement = node => /body/i.test(node == null ? void 0 : node.tagName);\nlet insertIntoElement = (originalTarget, character) => {\n  if (isInput(originalTarget)) {\n    originalTarget.value = `${originalTarget.value}${character.textContent}`;\n    return;\n  }\n  character.innerHTML = \"\";\n  let target = isBodyElement(character.originalParent) ? originalTarget :\n  // If we add one-off fresh elements, there will be no\n  // \"originalParent\", so always fall back to the default target.\n  character.originalParent || originalTarget;\n  target.insertBefore(character, select(\".\" + CURSOR_CLASS, target) || null);\n};\nconst isNonVoidElement = el => /<(.+)>(.*?)<\\/(.+)>/.test(el.outerHTML);\nconst merge = (originalObj, newObj) => Object.assign({}, originalObj, newObj);\nlet processCursorOptions = cursorOptions => {\n  var _a2, _b;\n  if (typeof cursorOptions === \"object\") {\n    let newOptions = {};\n    let {\n      frames: defaultFrames,\n      options: defaultOptions\n    } = DEFAULT_OPTIONS.cursor.animation;\n    newOptions.animation = cursorOptions.animation || {};\n    newOptions.animation.frames = ((_a2 = cursorOptions.animation) == null ? void 0 : _a2.frames) || defaultFrames;\n    newOptions.animation.options = merge(defaultOptions, ((_b = cursorOptions.animation) == null ? void 0 : _b.options) || {});\n    newOptions.autoPause = cursorOptions.autoPause ?? DEFAULT_OPTIONS.cursor.autoPause;\n    newOptions.autoPauseDelay = cursorOptions.autoPauseDelay || DEFAULT_OPTIONS.cursor.autoPauseDelay;\n    return newOptions;\n  }\n  if (cursorOptions === true) {\n    return DEFAULT_OPTIONS.cursor;\n  }\n  return cursorOptions;\n};\nconst removeNode = (node, rootElement) => {\n  if (!node) return;\n  let nodeParent = node.parentNode;\n  let nodeToRemove = nodeParent.childNodes.length > 1 || nodeParent.isSameNode(rootElement) ?\n  // This parent still needs to exist.\n  node :\n  // There's nothing else in there, so just delete the entire thing.\n  // By doing this, we clean up markup as we go along.\n  nodeParent;\n  nodeToRemove.remove();\n};\nconst repositionCursor = (element, allChars, newCursorPosition) => {\n  let nodeToInsertBefore = allChars[newCursorPosition - 1];\n  let cursor = select(`.${CURSOR_CLASS}`, element);\n  element = (nodeToInsertBefore == null ? void 0 : nodeToInsertBefore.parentNode) || element;\n  element.insertBefore(cursor, nodeToInsertBefore || null);\n};\nfunction selectorToElement(thing) {\n  return typeof thing === \"string\" ? select(thing) : thing;\n}\nlet cursorFontStyles = {\n  \"font-family\": \"\",\n  \"font-weight\": \"\",\n  \"font-size\": \"\",\n  \"font-style\": \"\",\n  \"line-height\": \"\",\n  color: \"\",\n  transform: \"translateX(-.125em)\"\n};\nlet setCursorStyles = (id, element) => {\n  let rootSelector = `[${DATA_ATTRIBUTE}='${id}']`;\n  let cursorSelector = `${rootSelector} .${CURSOR_CLASS}`;\n  let computedStyles = getComputedStyle(element);\n  let customProperties = Object.entries(cursorFontStyles).reduce((accumulator, [item, value]) => {\n    return `${accumulator} ${item}: var(--ti-cursor-${item}, ${value || computedStyles[item]});`;\n  }, \"\");\n  appendStyleBlock(`${cursorSelector} { display: inline-block; width: 0; ${customProperties} }`, id);\n};\nfunction splitOnBreak(str) {\n  return str.replace(/<!--(.+?)-->/g, \"\").trim().split(/<br(?:\\s*?)(?:\\/)?>/);\n}\nlet updateCursorPosition = (steps, cursorPosition, printedCharacters) => {\n  return Math.min(Math.max(cursorPosition + steps, 0), printedCharacters.length);\n};\nlet wait = (callback, delay, timeouts) => {\n  return new Promise(resolve => {\n    let cb = async () => {\n      await callback();\n      resolve();\n    };\n    timeouts.push(setTimeout(cb, delay || 0));\n  });\n};\nlet TypeIt$1 = (_a = class {\n  constructor(element, options = {}) {\n    __privateAdd(this, _empty);\n    /**\n     * Execute items in the queue.\n     *\n     * @param remember If false, each queue item will be destroyed once executed.\n     * @returns\n     */\n    __privateAdd(this, _fire);\n    __privateAdd(this, _move);\n    /**\n     * 1. Reset queue.\n     * 2. Reset initial pause.\n     */\n    __privateAdd(this, _prepLoop);\n    __privateAdd(this, _fireItemWithContext);\n    __privateAdd(this, _wait);\n    /**\n     * Attach it to the DOM so, along with the required CSS transition.\n     */\n    __privateAdd(this, _attachCursor);\n    __privateAdd(this, _elementIsInput);\n    __privateAdd(this, _queueAndReturn);\n    __privateAdd(this, _maybeAppendPause);\n    __privateAdd(this, _generateTemporaryOptionQueueItems);\n    __privateAdd(this, _updateOptions);\n    /**\n     * Based on provided strings, generate a TypeIt queue\n     * to be fired for each character in the string.\n     */\n    __privateAdd(this, _generateQueue);\n    __privateAdd(this, _prependHardcodedStrings);\n    /**\n     * Provided it's a non-form element and the options is provided,\n     * set up the cursor element for the animation.\n     */\n    __privateAdd(this, _setUpCursor);\n    __privateAdd(this, _addSplitPause);\n    __privateAdd(this, _type);\n    __privateAdd(this, _delete);\n    __privateAdd(this, _removeNode);\n    __privateAdd(this, _getPace);\n    __privateAdd(this, _derivedCursorPosition);\n    __privateAdd(this, _isInput);\n    __privateAdd(this, _shouldRenderCursor);\n    __privateAdd(this, _allChars);\n    __publicField(this, \"element\");\n    __publicField(this, \"timeouts\");\n    __publicField(this, \"cursorPosition\");\n    __publicField(this, \"predictedCursorPosition\");\n    __publicField(this, \"statuses\", {\n      started: false,\n      completed: false,\n      frozen: false,\n      destroyed: false\n    });\n    __publicField(this, \"opts\");\n    __publicField(this, \"id\");\n    __publicField(this, \"queue\");\n    __publicField(this, \"cursor\");\n    __publicField(this, \"unfreeze\", () => {});\n    __publicField(this, \"is\", function (key) {\n      return this.statuses[key];\n    });\n    __privateAdd(this, _buildOptions, options => {\n      options.cursor = processCursorOptions(options.cursor ?? DEFAULT_OPTIONS.cursor);\n      this.opts.strings = __privateMethod(this, _prependHardcodedStrings, prependHardcodedStrings_fn).call(this, asArray(this.opts.strings));\n      this.opts = merge(this.opts, {\n        html: !__privateGet(this, _isInput, isInput_get) && this.opts.html,\n        nextStringDelay: calculateDelay(this.opts.nextStringDelay),\n        loopDelay: calculateDelay(this.opts.loopDelay)\n      });\n    });\n    this.opts = merge(DEFAULT_OPTIONS, options);\n    this.element = selectorToElement(element);\n    this.timeouts = [];\n    this.cursorPosition = 0;\n    this.unfreeze = () => {};\n    this.predictedCursorPosition = null;\n    this.statuses = merge({}, DEFAULT_STATUSES);\n    this.id = generateHash();\n    this.queue = Queue([{\n      delay: this.opts.startDelay\n    }]);\n    __privateGet(this, _buildOptions).call(this, options);\n    this.cursor = __privateMethod(this, _setUpCursor, setUpCursor_fn).call(this);\n    this.element.dataset.typeitId = this.id;\n    appendStyleBlock(PLACEHOLDER_CSS);\n    if (this.opts.strings.length) {\n      __privateMethod(this, _generateQueue, generateQueue_fn).call(this);\n    }\n  }\n  /**\n   * Can only be called once.\n   */\n  go() {\n    if (this.statuses.started) {\n      return this;\n    }\n    __privateMethod(this, _attachCursor, attachCursor_fn).call(this);\n    if (!this.opts.waitUntilVisible) {\n      __privateMethod(this, _fire, fire_fn).call(this);\n      return this;\n    }\n    fireWhenVisible(this.element, __privateMethod(this, _fire, fire_fn).bind(this));\n    return this;\n  }\n  destroy(shouldRemoveCursor = true) {\n    this.timeouts = destroyTimeouts(this.timeouts);\n    handleFunctionalArg(shouldRemoveCursor) && this.cursor && __privateMethod(this, _removeNode, removeNode_fn).call(this, this.cursor);\n    this.statuses.destroyed = true;\n  }\n  reset(rebuild) {\n    !this.is(\"destroyed\") && this.destroy();\n    if (rebuild) {\n      this.queue.wipe();\n      rebuild(this);\n    } else {\n      this.queue.reset();\n    }\n    this.cursorPosition = 0;\n    for (let property in this.statuses) {\n      this.statuses[property] = false;\n    }\n    this.element[__privateMethod(this, _elementIsInput, elementIsInput_fn).call(this) ? \"value\" : \"innerHTML\"] = \"\";\n    return this;\n  }\n  type(string, actionOpts = {}) {\n    string = handleFunctionalArg(string);\n    let {\n      instant\n    } = actionOpts;\n    let bookEndQueueItems = __privateMethod(this, _generateTemporaryOptionQueueItems, generateTemporaryOptionQueueItems_fn).call(this, actionOpts);\n    let chars = maybeChunkStringAsHtml(string, this.opts.html);\n    let charsAsQueueItems = chars.map(char => {\n      return {\n        func: () => __privateMethod(this, _type, type_fn).call(this, char),\n        char,\n        delay: instant || isNonVoidElement(char) ? 0 : __privateMethod(this, _getPace, getPace_fn).call(this),\n        typeable: char.nodeType === Node.TEXT_NODE\n      };\n    });\n    let itemsToQueue = [bookEndQueueItems[0], {\n      func: async () => await this.opts.beforeString(string, this)\n    }, ...charsAsQueueItems, {\n      func: async () => await this.opts.afterString(string, this)\n    }, bookEndQueueItems[1]];\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, itemsToQueue, actionOpts);\n  }\n  break(actionOpts = {}) {\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, {\n      func: () => __privateMethod(this, _type, type_fn).call(this, createElement(\"BR\")),\n      typeable: true\n    }, actionOpts);\n  }\n  move(movementArg, actionOpts = {}) {\n    movementArg = handleFunctionalArg(movementArg);\n    let bookEndQueueItems = __privateMethod(this, _generateTemporaryOptionQueueItems, generateTemporaryOptionQueueItems_fn).call(this, actionOpts);\n    let {\n      instant,\n      to\n    } = actionOpts;\n    let numberOfSteps = countStepsToSelector({\n      queueItems: this.queue.getTypeable(),\n      selector: movementArg === null ? \"\" : movementArg,\n      to,\n      cursorPosition: __privateGet(this, _derivedCursorPosition, derivedCursorPosition_get)\n    });\n    let directionalStep = numberOfSteps < 0 ? -1 : 1;\n    this.predictedCursorPosition = __privateGet(this, _derivedCursorPosition, derivedCursorPosition_get) + numberOfSteps;\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, [bookEndQueueItems[0], ...duplicate({\n      func: () => __privateMethod(this, _move, move_fn).call(this, directionalStep),\n      delay: instant ? 0 : __privateMethod(this, _getPace, getPace_fn).call(this),\n      cursorable: true\n    }, Math.abs(numberOfSteps)), bookEndQueueItems[1]], actionOpts);\n  }\n  exec(func, actionOpts = {}) {\n    let bookEndQueueItems = __privateMethod(this, _generateTemporaryOptionQueueItems, generateTemporaryOptionQueueItems_fn).call(this, actionOpts);\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, [bookEndQueueItems[0], {\n      func: () => func(this)\n    }, bookEndQueueItems[1]], actionOpts);\n  }\n  options(opts, actionOpts = {}) {\n    opts = handleFunctionalArg(opts);\n    __privateMethod(this, _updateOptions, updateOptions_fn).call(this, opts);\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, {}, actionOpts);\n  }\n  pause(milliseconds, actionOpts = {}) {\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, {\n      delay: handleFunctionalArg(milliseconds)\n    }, actionOpts);\n  }\n  delete(numCharacters = null, actionOpts = {}) {\n    numCharacters = handleFunctionalArg(numCharacters);\n    let bookEndQueueItems = __privateMethod(this, _generateTemporaryOptionQueueItems, generateTemporaryOptionQueueItems_fn).call(this, actionOpts);\n    let num = numCharacters;\n    let {\n      instant,\n      to\n    } = actionOpts;\n    let typeableQueueItems = this.queue.getTypeable();\n    let rounds = (() => {\n      if (num === null) {\n        return typeableQueueItems.length;\n      }\n      if (isNumber(num)) {\n        return num;\n      }\n      return countStepsToSelector({\n        queueItems: typeableQueueItems,\n        selector: num,\n        cursorPosition: __privateGet(this, _derivedCursorPosition, derivedCursorPosition_get),\n        to\n      });\n    })();\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, [bookEndQueueItems[0], ...duplicate({\n      func: __privateMethod(this, _delete, delete_fn).bind(this),\n      delay: instant ? 0 : __privateMethod(this, _getPace, getPace_fn).call(this, 1),\n      deletable: true\n    }, rounds), bookEndQueueItems[1]], actionOpts);\n  }\n  freeze() {\n    this.statuses.frozen = true;\n  }\n  /**\n   * Like `.go()`, but more... \"off the grid.\"\n   *\n   * - won't trigger `afterComplete` callback\n   * - items won't be replayed after `.reset()`\n   *\n   * When called, all non-done items will be \"flushed\" --\n   * that is, executed, but not remembered.\n   */\n  flush(cb = () => {}) {\n    __privateMethod(this, _attachCursor, attachCursor_fn).call(this);\n    __privateMethod(this, _fire, fire_fn).call(this, false).then(cb);\n    return this;\n  }\n  getQueue() {\n    return this.queue;\n  }\n  getOptions() {\n    return this.opts;\n  }\n  updateOptions(options) {\n    return __privateMethod(this, _updateOptions, updateOptions_fn).call(this, options);\n  }\n  getElement() {\n    return this.element;\n  }\n  empty(actionOpts = {}) {\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, {\n      func: __privateMethod(this, _empty, empty_fn).bind(this)\n    }, actionOpts);\n  }\n}, _empty = new WeakSet(), empty_fn = async function () {\n  if (__privateMethod(this, _elementIsInput, elementIsInput_fn).call(this)) {\n    this.element.value = \"\";\n    return;\n  }\n  __privateGet(this, _allChars, allChars_get).forEach(__privateMethod(this, _removeNode, removeNode_fn).bind(this));\n  return;\n}, _fire = new WeakSet(), fire_fn = async function (remember = true) {\n  this.statuses.started = true;\n  let cleanUp = qKey => {\n    this.queue.done(qKey, !remember);\n  };\n  try {\n    let queueItems = [...this.queue.getQueue()];\n    for (let index = 0; index < queueItems.length; index++) {\n      let [queueKey, queueItem] = queueItems[index];\n      if (queueItem.done) continue;\n      if (!queueItem.deletable || queueItem.deletable && __privateGet(this, _allChars, allChars_get).length) {\n        let newIndex = await __privateMethod(this, _fireItemWithContext, fireItemWithContext_fn).call(this, index, queueItems);\n        Array(newIndex - index).fill(index + 1).map((x, y) => x + y).forEach(i => {\n          let [key] = queueItems[i];\n          cleanUp(key);\n        });\n        index = newIndex;\n      }\n      cleanUp(queueKey);\n    }\n    if (!remember) {\n      return this;\n    }\n    this.statuses.completed = true;\n    await this.opts.afterComplete(this);\n    if (!this.opts.loop) {\n      throw \"\";\n    }\n    let delay = this.opts.loopDelay;\n    __privateMethod(this, _wait, wait_fn).call(this, async () => {\n      await __privateMethod(this, _prepLoop, prepLoop_fn).call(this, delay[0]);\n      __privateMethod(this, _fire, fire_fn).call(this);\n    }, delay[1]);\n  } catch (e) {}\n  return this;\n}, _move = new WeakSet(), move_fn = async function (step) {\n  this.cursorPosition = updateCursorPosition(step, this.cursorPosition, __privateGet(this, _allChars, allChars_get));\n  repositionCursor(this.element, __privateGet(this, _allChars, allChars_get), this.cursorPosition);\n}, _prepLoop = new WeakSet(), prepLoop_fn = async function (delay) {\n  let derivedCursorPosition = __privateGet(this, _derivedCursorPosition, derivedCursorPosition_get);\n  derivedCursorPosition && (await __privateMethod(this, _move, move_fn).call(this, {\n    value: derivedCursorPosition\n  }));\n  let queueItems = __privateGet(this, _allChars, allChars_get).map(c => {\n    return [Symbol(), {\n      func: __privateMethod(this, _delete, delete_fn).bind(this),\n      delay: __privateMethod(this, _getPace, getPace_fn).call(this, 1),\n      deletable: true,\n      shouldPauseCursor: () => true\n    }];\n  });\n  for (let index = 0; index < queueItems.length; index++) {\n    await __privateMethod(this, _fireItemWithContext, fireItemWithContext_fn).call(this, index, queueItems);\n  }\n  this.queue.reset();\n  this.queue.set(0, {\n    delay\n  });\n}, _fireItemWithContext = new WeakSet(), fireItemWithContext_fn = function (index, queueItems) {\n  return fireItem({\n    index,\n    queueItems,\n    wait: __privateMethod(this, _wait, wait_fn).bind(this),\n    cursor: this.cursor,\n    cursorOptions: this.opts.cursor\n  });\n}, _wait = new WeakSet(), wait_fn = async function (callback, delay, silent = false) {\n  if (this.statuses.frozen) {\n    await new Promise(resolve => {\n      this.unfreeze = () => {\n        this.statuses.frozen = false;\n        resolve();\n      };\n    });\n  }\n  silent || (await this.opts.beforeStep(this));\n  await wait(callback, delay, this.timeouts);\n  silent || (await this.opts.afterStep(this));\n}, _attachCursor = new WeakSet(), attachCursor_fn = async function () {\n  !__privateMethod(this, _elementIsInput, elementIsInput_fn).call(this) && this.cursor && this.element.appendChild(this.cursor);\n  if (__privateGet(this, _shouldRenderCursor, shouldRenderCursor_get)) {\n    setCursorStyles(this.id, this.element);\n    this.cursor.dataset.tiAnimationId = this.id;\n    let {\n      animation\n    } = this.opts.cursor;\n    let {\n      frames,\n      options\n    } = animation;\n    setCursorAnimation({\n      frames,\n      cursor: this.cursor,\n      options: {\n        duration: this.opts.cursorSpeed,\n        ...options\n      }\n    });\n  }\n}, _elementIsInput = new WeakSet(), elementIsInput_fn = function () {\n  return isInput(this.element);\n}, _queueAndReturn = new WeakSet(), queueAndReturn_fn = function (steps, opts) {\n  this.queue.add(steps);\n  __privateMethod(this, _maybeAppendPause, maybeAppendPause_fn).call(this, opts);\n  return this;\n}, _maybeAppendPause = new WeakSet(), maybeAppendPause_fn = function (opts = {}) {\n  let delay = opts.delay;\n  delay && this.queue.add({\n    delay\n  });\n}, _generateTemporaryOptionQueueItems = new WeakSet(), generateTemporaryOptionQueueItems_fn = function (newOptions = {}) {\n  return [{\n    func: () => __privateMethod(this, _updateOptions, updateOptions_fn).call(this, newOptions)\n  }, {\n    func: () => __privateMethod(this, _updateOptions, updateOptions_fn).call(this, this.opts)\n  }];\n}, _updateOptions = new WeakSet(), updateOptions_fn = async function (opts) {\n  this.opts = merge(this.opts, opts);\n}, _generateQueue = new WeakSet(), generateQueue_fn = function () {\n  let strings = this.opts.strings.filter(string => !!string);\n  strings.forEach((string, index) => {\n    this.type(string);\n    if (index + 1 === strings.length) {\n      return;\n    }\n    let splitItems = this.opts.breakLines ? [{\n      func: () => __privateMethod(this, _type, type_fn).call(this, createElement(\"BR\")),\n      typeable: true\n    }] : duplicate({\n      func: __privateMethod(this, _delete, delete_fn).bind(this),\n      delay: __privateMethod(this, _getPace, getPace_fn).call(this, 1)\n    }, this.queue.getTypeable().length);\n    __privateMethod(this, _addSplitPause, addSplitPause_fn).call(this, splitItems);\n  });\n}, _buildOptions = new WeakMap(), _prependHardcodedStrings = new WeakSet(), prependHardcodedStrings_fn = function (strings) {\n  let existingMarkup = this.element.innerHTML;\n  if (!existingMarkup) {\n    return strings;\n  }\n  this.element.innerHTML = \"\";\n  if (this.opts.startDelete) {\n    this.element.innerHTML = existingMarkup;\n    expandTextNodes(this.element);\n    __privateMethod(this, _addSplitPause, addSplitPause_fn).call(this, duplicate({\n      func: __privateMethod(this, _delete, delete_fn).bind(this),\n      delay: __privateMethod(this, _getPace, getPace_fn).call(this, 1),\n      deletable: true\n    }, __privateGet(this, _allChars, allChars_get).length));\n    return strings;\n  }\n  return splitOnBreak(existingMarkup).concat(strings);\n}, _setUpCursor = new WeakSet(), setUpCursor_fn = function () {\n  if (__privateGet(this, _isInput, isInput_get)) {\n    return null;\n  }\n  let cursor = createElement(\"span\");\n  cursor.className = CURSOR_CLASS;\n  if (!__privateGet(this, _shouldRenderCursor, shouldRenderCursor_get)) {\n    cursor.style.visibility = \"hidden\";\n    return cursor;\n  }\n  cursor.innerHTML = getParsedBody(this.opts.cursorChar).innerHTML;\n  return cursor;\n}, _addSplitPause = new WeakSet(), addSplitPause_fn = function (items) {\n  let delay = this.opts.nextStringDelay;\n  this.queue.add([{\n    delay: delay[0]\n  }, ...items, {\n    delay: delay[1]\n  }]);\n}, _type = new WeakSet(), type_fn = function (char) {\n  insertIntoElement(this.element, char);\n}, _delete = new WeakSet(), delete_fn = function () {\n  if (!__privateGet(this, _allChars, allChars_get).length) return;\n  if (__privateGet(this, _isInput, isInput_get)) {\n    this.element.value = this.element.value.slice(0, -1);\n  } else {\n    __privateMethod(this, _removeNode, removeNode_fn).call(this, __privateGet(this, _allChars, allChars_get)[this.cursorPosition]);\n  }\n}, _removeNode = new WeakSet(), removeNode_fn = function (node) {\n  removeNode(node, this.element);\n}, _getPace = new WeakSet(), getPace_fn = function (index = 0) {\n  return calculatePace(this.opts)[index];\n}, _derivedCursorPosition = new WeakSet(), derivedCursorPosition_get = function () {\n  return this.predictedCursorPosition ?? this.cursorPosition;\n}, _isInput = new WeakSet(), isInput_get = function () {\n  return isInput(this.element);\n}, _shouldRenderCursor = new WeakSet(), shouldRenderCursor_get = function () {\n  return !!this.opts.cursor && !__privateGet(this, _isInput, isInput_get);\n}, _allChars = new WeakSet(), allChars_get = function () {\n  return getAllChars(this.element);\n}, _a);\nconst DynamicElementComponent = forwardRef((props, ref) => {\n  const {\n    as: As\n  } = props;\n  return /* @__PURE__ */React.createElement(As, {\n    ref,\n    ...props\n  });\n});\nconst defaultPropOptions = {};\nconst TypeIt = ({\n  as = \"span\",\n  options = defaultPropOptions,\n  children = null,\n  getBeforeInit = instance => instance,\n  getAfterInit = instance => instance,\n  ...remainingProps\n}) => {\n  const elementRef = useRef(null);\n  const instanceRef = useRef(null);\n  const [shouldShowChildren, setShouldShowChildren] = useState(true);\n  const [instanceOptions, setInstanceOptions] = useState(null);\n  function calculateOptions() {\n    const optionsClone = Object.assign({}, options);\n    if (children && elementRef.current) {\n      optionsClone.strings = elementRef.current.innerHTML;\n    }\n    setInstanceOptions(optionsClone);\n  }\n  function generateNewInstance() {\n    instanceRef.current = new TypeIt$1(elementRef.current, instanceOptions);\n    instanceRef.current = getBeforeInit(instanceRef.current);\n    instanceRef.current.go();\n    instanceRef.current = getAfterInit(instanceRef.current);\n  }\n  useEffect(() => {\n    calculateOptions();\n    setShouldShowChildren(false);\n  }, [options]);\n  useEffect(() => {\n    var _a2;\n    if (!instanceOptions) return;\n    ((_a2 = instanceRef.current) == null ? void 0 : _a2.updateOptions(instanceOptions)) || generateNewInstance();\n  }, [instanceOptions]);\n  useEffect(() => {\n    return () => {\n      var _a2;\n      return (_a2 = instanceRef.current) == null ? void 0 : _a2.destroy();\n    };\n  }, []);\n  return /* @__PURE__ */React.createElement(DynamicElementComponent, {\n    ref: elementRef,\n    as,\n    children: shouldShowChildren ? children : null,\n    style: {\n      opacity: shouldShowChildren ? 0 : 1\n    },\n    ...remainingProps\n  });\n};\nexport { TypeIt as default };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","__accessCheck","member","msg","has","TypeError","__privateGet","getter","call","get","__privateAdd","WeakSet","add","set","__privateMethod","method","_empty","empty_fn","_fire","fire_fn","_move","move_fn","_prepLoop","prepLoop_fn","_fireItemWithContext","fireItemWithContext_fn","_wait","wait_fn","_attachCursor","attachCursor_fn","_elementIsInput","elementIsInput_fn","_queueAndReturn","queueAndReturn_fn","_maybeAppendPause","maybeAppendPause_fn","_generateTemporaryOptionQueueItems","generateTemporaryOptionQueueItems_fn","_updateOptions","updateOptions_fn","_generateQueue","generateQueue_fn","_buildOptions","_prependHardcodedStrings","prependHardcodedStrings_fn","_setUpCursor","setUpCursor_fn","_addSplitPause","addSplitPause_fn","_type","type_fn","_delete","delete_fn","_removeNode","removeNode_fn","_getPace","getPace_fn","_derivedCursorPosition","derivedCursorPosition_get","_isInput","isInput_get","_shouldRenderCursor","shouldRenderCursor_get","_allChars","allChars_get","_a","React","forwardRef","useRef","useState","useEffect","isArray","thing","Array","asArray","Queue","initialItems","steps","forEach","step","_a2","_q","Symbol","char","innerText","buildQueueItem","getTypeable","rawValues","filter","typeable","index","item","keys","queueItem","shouldPauseCursor","Boolean","cursorable","deletable","reset","done","wipe","Map","getQueue","from","values","destroy","delete","getItems","all","i","shouldDestroy","DATA_ATTRIBUTE","CURSOR_CLASS","END","DEFAULT_STATUSES","started","completed","frozen","destroyed","DEFAULT_OPTIONS","breakLines","cursor","autoPause","autoPauseDelay","animation","frames","map","n","opacity","options","iterations","Infinity","easing","fill","cursorChar","cursorSpeed","deleteSpeed","html","lifeLike","loop","loopDelay","nextStringDelay","speed","startDelay","startDelete","strings","waitUntilVisible","beforeString","afterString","beforeStep","afterStep","afterComplete","PLACEHOLDER_CSS","createElement","el","document","createTextNode","content","appendStyleBlock","styles","id","styleBlock","appendChild","head","calculateDelay","delayArg","randomInRange","range2","Math","abs","random","range","val","calculatePace","toArray","expandTextNodes","element","childNodes","child","nodeValue","c","parentNode","insertBefore","remove","getParsedBody","doc","implementation","createHTMLDocument","body","innerHTML","walkElementNodes","shouldReverse","shouldIncludeCursor","querySelector","walker","createTreeWalker","NodeFilter","SHOW_ALL","acceptNode","node","_b","classList","contains","FILTER_ACCEPT","FILTER_REJECT","nextNode","nodes","originalParent","push","reverse","chunkStringAsHtml","string","maybeChunkStringAsHtml","str","asHtml","isNumber","Number","isInteger","countStepsToSelector","queueItems","selector","cursorPosition","to","isMovingToEnd","RegExp","test","selectorIndex","findIndex","parentElement","parentMatches","matches","firstChild","isSameNode","length","offset","destroyTimeouts","timeouts","clearTimeout","duplicate","times","beforePaint","cb","Promise","resolve","requestAnimationFrame","getAnimationFromElement","getAnimations","find","dataset","tiAnimationId","setCursorAnimation","animate","pause","play","rebuildCursorAnimation","cursorOptions","oldCurrentTime","delay","effect","getComputedTiming","currentTime","cancel","newAnimation","execute","func","fireItem","wait","wait2","instantQueue","tempIndex","futureItem","shouldBeGrouped","q","fireWhenVisible","observer","IntersectionObserver","entries","observer2","entry","isIntersecting","unobserve","threshold","observe","generateHash","toString","substring","isInput","getAllChars","handleFunctionalArg","arg","select","isBodyElement","tagName","insertIntoElement","originalTarget","character","textContent","target","isNonVoidElement","outerHTML","merge","originalObj","newObj","assign","processCursorOptions","newOptions","defaultFrames","defaultOptions","removeNode","rootElement","nodeParent","nodeToRemove","repositionCursor","allChars","newCursorPosition","nodeToInsertBefore","selectorToElement","cursorFontStyles","color","transform","setCursorStyles","rootSelector","cursorSelector","computedStyles","getComputedStyle","customProperties","reduce","accumulator","splitOnBreak","replace","trim","split","updateCursorPosition","printedCharacters","min","max","callback","setTimeout","TypeIt$1","constructor","statuses","opts","unfreeze","predictedCursorPosition","queue","typeitId","go","bind","shouldRemoveCursor","rebuild","is","property","type","actionOpts","instant","bookEndQueueItems","chars","charsAsQueueItems","nodeType","Node","TEXT_NODE","itemsToQueue","break","move","movementArg","numberOfSteps","directionalStep","exec","milliseconds","numCharacters","num","typeableQueueItems","rounds","freeze","flush","then","getOptions","updateOptions","getElement","empty","remember","cleanUp","qKey","queueKey","newIndex","x","y","e","derivedCursorPosition","silent","duration","splitItems","WeakMap","existingMarkup","concat","className","style","visibility","items","slice","DynamicElementComponent","props","ref","as","As","defaultPropOptions","TypeIt","children","getBeforeInit","instance","getAfterInit","remainingProps","elementRef","instanceRef","shouldShowChildren","setShouldShowChildren","instanceOptions","setInstanceOptions","calculateOptions","optionsClone","current","generateNewInstance","default"],"sources":["/Users/mac/Desktop/oz_coding/4월미니프로젝트/aprillproject/Aprill_project/frontend/node_modules/typeit-react/dist/index.es.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _empty, empty_fn, _fire, fire_fn, _move, move_fn, _prepLoop, prepLoop_fn, _fireItemWithContext, fireItemWithContext_fn, _wait, wait_fn, _attachCursor, attachCursor_fn, _elementIsInput, elementIsInput_fn, _queueAndReturn, queueAndReturn_fn, _maybeAppendPause, maybeAppendPause_fn, _generateTemporaryOptionQueueItems, generateTemporaryOptionQueueItems_fn, _updateOptions, updateOptions_fn, _generateQueue, generateQueue_fn, _buildOptions, _prependHardcodedStrings, prependHardcodedStrings_fn, _setUpCursor, setUpCursor_fn, _addSplitPause, addSplitPause_fn, _type, type_fn, _delete, delete_fn, _removeNode, removeNode_fn, _getPace, getPace_fn, _derivedCursorPosition, derivedCursorPosition_get, _isInput, isInput_get, _shouldRenderCursor, shouldRenderCursor_get, _allChars, allChars_get, _a;\nimport React, { forwardRef, useRef, useState, useEffect } from \"react\";\nconst isArray = (thing) => Array.isArray(thing);\nconst asArray = (value) => isArray(value) ? value : [value];\nlet Queue = function(initialItems) {\n  let add = function(steps) {\n    asArray(steps).forEach((step) => {\n      var _a2;\n      return _q.set(Symbol((_a2 = step.char) == null ? void 0 : _a2.innerText), buildQueueItem({ ...step }));\n    });\n    return this;\n  };\n  let getTypeable = () => rawValues().filter((value) => value.typeable);\n  let set = function(index, item) {\n    let keys = [..._q.keys()];\n    _q.set(keys[index], buildQueueItem(item));\n  };\n  let buildQueueItem = (queueItem) => {\n    queueItem.shouldPauseCursor = function() {\n      return Boolean(this.typeable || this.cursorable || this.deletable);\n    };\n    return queueItem;\n  };\n  let reset = function() {\n    _q.forEach((item) => delete item.done);\n  };\n  let wipe = function() {\n    _q = /* @__PURE__ */ new Map();\n    add(initialItems);\n  };\n  let getQueue = () => _q;\n  let rawValues = () => Array.from(_q.values());\n  let destroy = (key) => _q.delete(key);\n  let getItems = (all = false) => all ? rawValues() : rawValues().filter((i) => !i.done);\n  let done = (key, shouldDestroy = false) => shouldDestroy ? _q.delete(key) : _q.get(key).done = true;\n  let _q = /* @__PURE__ */ new Map();\n  add(initialItems);\n  return {\n    add,\n    set,\n    wipe,\n    done,\n    reset,\n    destroy,\n    getItems,\n    getQueue,\n    getTypeable\n  };\n};\nconst DATA_ATTRIBUTE = \"data-typeit-id\";\nconst CURSOR_CLASS = \"ti-cursor\";\nconst END = \"END\";\nconst DEFAULT_STATUSES = {\n  started: false,\n  completed: false,\n  frozen: false,\n  destroyed: false\n};\nconst DEFAULT_OPTIONS = {\n  breakLines: true,\n  cursor: {\n    autoPause: true,\n    autoPauseDelay: 500,\n    animation: {\n      frames: [0, 0, 1].map((n) => {\n        return { opacity: n };\n      }),\n      options: {\n        iterations: Infinity,\n        easing: \"steps(2, start)\",\n        fill: \"forwards\"\n      }\n    }\n  },\n  cursorChar: \"|\",\n  cursorSpeed: 1e3,\n  deleteSpeed: null,\n  html: true,\n  lifeLike: true,\n  loop: false,\n  loopDelay: 750,\n  nextStringDelay: 750,\n  speed: 100,\n  startDelay: 250,\n  startDelete: false,\n  strings: [],\n  waitUntilVisible: false,\n  beforeString: () => {\n  },\n  afterString: () => {\n  },\n  beforeStep: () => {\n  },\n  afterStep: () => {\n  },\n  afterComplete: () => {\n  }\n};\nconst PLACEHOLDER_CSS = `[${DATA_ATTRIBUTE}]:before {content: '.'; display: inline-block; width: 0; visibility: hidden;}`;\nconst createElement = (el) => document.createElement(el);\nconst createTextNode = (content) => document.createTextNode(content);\nconst appendStyleBlock = (styles, id = \"\") => {\n  let styleBlock = createElement(\"style\");\n  styleBlock.id = id;\n  styleBlock.appendChild(createTextNode(styles));\n  document.head.appendChild(styleBlock);\n};\nconst calculateDelay = (delayArg) => {\n  if (!isArray(delayArg)) {\n    delayArg = [delayArg / 2, delayArg / 2];\n  }\n  return delayArg;\n};\nconst randomInRange = (value, range2) => {\n  return Math.abs(\n    Math.random() * (value + range2 - (value - range2)) + (value - range2)\n  );\n};\nlet range = (val) => val / 2;\nfunction calculatePace(options) {\n  let { speed, deleteSpeed, lifeLike } = options;\n  deleteSpeed = deleteSpeed !== null ? deleteSpeed : speed / 3;\n  return lifeLike ? [\n    randomInRange(speed, range(speed)),\n    randomInRange(deleteSpeed, range(deleteSpeed))\n  ] : [speed, deleteSpeed];\n}\nconst toArray = (val) => Array.from(val);\nlet expandTextNodes = (element) => {\n  [...element.childNodes].forEach((child) => {\n    if (child.nodeValue) {\n      [...child.nodeValue].forEach((c) => {\n        child.parentNode.insertBefore(createTextNode(c), child);\n      });\n      child.remove();\n      return;\n    }\n    expandTextNodes(child);\n  });\n  return element;\n};\nconst getParsedBody = (content) => {\n  let doc = document.implementation.createHTMLDocument();\n  doc.body.innerHTML = content;\n  return expandTextNodes(doc.body);\n};\nfunction walkElementNodes(element, shouldReverse = false, shouldIncludeCursor = false) {\n  let cursor = element.querySelector(`.${CURSOR_CLASS}`);\n  let walker = document.createTreeWalker(element, NodeFilter.SHOW_ALL, {\n    acceptNode: (node) => {\n      var _a2, _b;\n      if (cursor && shouldIncludeCursor) {\n        if ((_a2 = node.classList) == null ? void 0 : _a2.contains(CURSOR_CLASS)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n        if (cursor.contains(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n      return ((_b = node.classList) == null ? void 0 : _b.contains(CURSOR_CLASS)) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;\n    }\n  });\n  let nextNode;\n  let nodes = [];\n  while (nextNode = walker.nextNode()) {\n    if (!nextNode.originalParent) {\n      nextNode.originalParent = nextNode.parentNode;\n    }\n    nodes.push(nextNode);\n  }\n  return shouldReverse ? nodes.reverse() : nodes;\n}\nfunction chunkStringAsHtml(string) {\n  return walkElementNodes(getParsedBody(string));\n}\nfunction maybeChunkStringAsHtml(str, asHtml = true) {\n  return asHtml ? chunkStringAsHtml(str) : toArray(str).map(createTextNode);\n}\nconst isNumber = (value) => Number.isInteger(value);\nconst countStepsToSelector = ({\n  queueItems,\n  selector,\n  cursorPosition,\n  to\n}) => {\n  if (isNumber(selector)) {\n    return selector * -1;\n  }\n  let isMovingToEnd = new RegExp(END, \"i\").test(to);\n  let selectorIndex = selector ? [...queueItems].reverse().findIndex(({ char }) => {\n    let parentElement = char.parentElement;\n    let parentMatches = parentElement.matches(selector);\n    if (isMovingToEnd && parentMatches) {\n      return true;\n    }\n    return parentMatches && parentElement.firstChild.isSameNode(char);\n  }) : -1;\n  if (selectorIndex < 0) {\n    selectorIndex = isMovingToEnd ? 0 : queueItems.length - 1;\n  }\n  let offset = isMovingToEnd ? 0 : 1;\n  return selectorIndex - cursorPosition + offset;\n};\nconst destroyTimeouts = (timeouts) => {\n  timeouts.forEach(clearTimeout);\n  return [];\n};\nconst duplicate = (value, times) => new Array(times).fill(value);\nlet beforePaint = (cb) => {\n  return new Promise((resolve) => {\n    requestAnimationFrame(async () => {\n      resolve(await cb());\n    });\n  });\n};\nlet getAnimationFromElement = (element) => {\n  return element == null ? void 0 : element.getAnimations().find((animation) => {\n    return animation.id === element.dataset.tiAnimationId;\n  });\n};\nlet setCursorAnimation = ({\n  cursor,\n  frames,\n  options\n}) => {\n  let animation = cursor.animate(frames, options);\n  animation.pause();\n  animation.id = cursor.dataset.tiAnimationId;\n  beforePaint(() => {\n    beforePaint(() => {\n      animation.play();\n    });\n  });\n  return animation;\n};\nlet rebuildCursorAnimation = ({\n  cursor,\n  options,\n  cursorOptions\n}) => {\n  if (!cursor || !cursorOptions)\n    return;\n  let animation = getAnimationFromElement(cursor);\n  let oldCurrentTime;\n  if (animation) {\n    options.delay = animation.effect.getComputedTiming().delay;\n    oldCurrentTime = animation.currentTime;\n    animation.cancel();\n  }\n  let newAnimation = setCursorAnimation({\n    cursor,\n    frames: cursorOptions.animation.frames,\n    options\n  });\n  if (oldCurrentTime) {\n    newAnimation.currentTime = oldCurrentTime;\n  }\n  return newAnimation;\n};\nlet execute = (queueItem) => {\n  var _a2;\n  return (_a2 = queueItem.func) == null ? void 0 : _a2.call(null);\n};\nlet fireItem = async ({\n  index,\n  queueItems,\n  wait: wait2,\n  cursor,\n  cursorOptions\n}) => {\n  let queueItem = queueItems[index][1];\n  let instantQueue = [];\n  let tempIndex = index;\n  let futureItem = queueItem;\n  let shouldBeGrouped = () => futureItem && !futureItem.delay;\n  let shouldPauseCursor = queueItem.shouldPauseCursor() && cursorOptions.autoPause;\n  while (shouldBeGrouped()) {\n    instantQueue.push(futureItem);\n    shouldBeGrouped() && tempIndex++;\n    futureItem = queueItems[tempIndex] ? queueItems[tempIndex][1] : null;\n  }\n  if (instantQueue.length) {\n    await beforePaint(async () => {\n      for (let q of instantQueue) {\n        await execute(q);\n      }\n    });\n    return tempIndex - 1;\n  }\n  let animation = getAnimationFromElement(cursor);\n  let options;\n  if (animation) {\n    options = {\n      ...animation.effect.getComputedTiming(),\n      delay: shouldPauseCursor ? cursorOptions.autoPauseDelay : 0\n    };\n  }\n  await wait2(async () => {\n    if (animation && shouldPauseCursor) {\n      animation.cancel();\n    }\n    await beforePaint(() => {\n      execute(queueItem);\n    });\n  }, queueItem.delay);\n  await rebuildCursorAnimation({\n    cursor,\n    options,\n    cursorOptions\n  });\n  return index;\n};\nconst fireWhenVisible = (element, func) => {\n  let observer = new IntersectionObserver(\n    (entries, observer2) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          func();\n          observer2.unobserve(element);\n        }\n      });\n    },\n    { threshold: 1 }\n  );\n  observer.observe(element);\n};\nconst generateHash = () => Math.random().toString().substring(2, 9);\nconst isInput = (el) => {\n  return \"value\" in el;\n};\nlet getAllChars = (element) => {\n  if (isInput(element)) {\n    return toArray(element.value);\n  }\n  return walkElementNodes(element, true).filter(\n    (c) => !(c.childNodes.length > 0)\n  );\n};\nlet handleFunctionalArg = (arg) => {\n  return typeof arg === \"function\" ? arg() : arg;\n};\nlet select = (selector, element = document, all = false) => {\n  return element[`querySelector${all ? \"All\" : \"\"}`](selector);\n};\nlet isBodyElement = (node) => /body/i.test(node == null ? void 0 : node.tagName);\nlet insertIntoElement = (originalTarget, character) => {\n  if (isInput(originalTarget)) {\n    originalTarget.value = `${originalTarget.value}${character.textContent}`;\n    return;\n  }\n  character.innerHTML = \"\";\n  let target = isBodyElement(character.originalParent) ? originalTarget : (\n    // If we add one-off fresh elements, there will be no\n    // \"originalParent\", so always fall back to the default target.\n    character.originalParent || originalTarget\n  );\n  target.insertBefore(\n    character,\n    select(\".\" + CURSOR_CLASS, target) || null\n  );\n};\nconst isNonVoidElement = (el) => /<(.+)>(.*?)<\\/(.+)>/.test(el.outerHTML);\nconst merge = (originalObj, newObj) => Object.assign({}, originalObj, newObj);\nlet processCursorOptions = (cursorOptions) => {\n  var _a2, _b;\n  if (typeof cursorOptions === \"object\") {\n    let newOptions = {};\n    let { frames: defaultFrames, options: defaultOptions } = DEFAULT_OPTIONS.cursor.animation;\n    newOptions.animation = cursorOptions.animation || {};\n    newOptions.animation.frames = ((_a2 = cursorOptions.animation) == null ? void 0 : _a2.frames) || defaultFrames;\n    newOptions.animation.options = merge(\n      defaultOptions,\n      ((_b = cursorOptions.animation) == null ? void 0 : _b.options) || {}\n    );\n    newOptions.autoPause = cursorOptions.autoPause ?? DEFAULT_OPTIONS.cursor.autoPause;\n    newOptions.autoPauseDelay = cursorOptions.autoPauseDelay || DEFAULT_OPTIONS.cursor.autoPauseDelay;\n    return newOptions;\n  }\n  if (cursorOptions === true) {\n    return DEFAULT_OPTIONS.cursor;\n  }\n  return cursorOptions;\n};\nconst removeNode = (node, rootElement) => {\n  if (!node)\n    return;\n  let nodeParent = node.parentNode;\n  let nodeToRemove = nodeParent.childNodes.length > 1 || nodeParent.isSameNode(rootElement) ? (\n    // This parent still needs to exist.\n    node\n  ) : (\n    // There's nothing else in there, so just delete the entire thing.\n    // By doing this, we clean up markup as we go along.\n    nodeParent\n  );\n  nodeToRemove.remove();\n};\nconst repositionCursor = (element, allChars, newCursorPosition) => {\n  let nodeToInsertBefore = allChars[newCursorPosition - 1];\n  let cursor = select(`.${CURSOR_CLASS}`, element);\n  element = (nodeToInsertBefore == null ? void 0 : nodeToInsertBefore.parentNode) || element;\n  element.insertBefore(cursor, nodeToInsertBefore || null);\n};\nfunction selectorToElement(thing) {\n  return typeof thing === \"string\" ? select(thing) : thing;\n}\nlet cursorFontStyles = {\n  \"font-family\": \"\",\n  \"font-weight\": \"\",\n  \"font-size\": \"\",\n  \"font-style\": \"\",\n  \"line-height\": \"\",\n  color: \"\",\n  transform: \"translateX(-.125em)\"\n};\nlet setCursorStyles = (id, element) => {\n  let rootSelector = `[${DATA_ATTRIBUTE}='${id}']`;\n  let cursorSelector = `${rootSelector} .${CURSOR_CLASS}`;\n  let computedStyles = getComputedStyle(element);\n  let customProperties = Object.entries(cursorFontStyles).reduce(\n    (accumulator, [item, value]) => {\n      return `${accumulator} ${item}: var(--ti-cursor-${item}, ${value || computedStyles[item]});`;\n    },\n    \"\"\n  );\n  appendStyleBlock(\n    `${cursorSelector} { display: inline-block; width: 0; ${customProperties} }`,\n    id\n  );\n};\nfunction splitOnBreak(str) {\n  return str.replace(/<!--(.+?)-->/g, \"\").trim().split(/<br(?:\\s*?)(?:\\/)?>/);\n}\nlet updateCursorPosition = (steps, cursorPosition, printedCharacters) => {\n  return Math.min(\n    Math.max(cursorPosition + steps, 0),\n    printedCharacters.length\n  );\n};\nlet wait = (callback, delay, timeouts) => {\n  return new Promise((resolve) => {\n    let cb = async () => {\n      await callback();\n      resolve();\n    };\n    timeouts.push(setTimeout(cb, delay || 0));\n  });\n};\nlet TypeIt$1 = (_a = class {\n  constructor(element, options = {}) {\n    __privateAdd(this, _empty);\n    /**\n     * Execute items in the queue.\n     *\n     * @param remember If false, each queue item will be destroyed once executed.\n     * @returns\n     */\n    __privateAdd(this, _fire);\n    __privateAdd(this, _move);\n    /**\n     * 1. Reset queue.\n     * 2. Reset initial pause.\n     */\n    __privateAdd(this, _prepLoop);\n    __privateAdd(this, _fireItemWithContext);\n    __privateAdd(this, _wait);\n    /**\n     * Attach it to the DOM so, along with the required CSS transition.\n     */\n    __privateAdd(this, _attachCursor);\n    __privateAdd(this, _elementIsInput);\n    __privateAdd(this, _queueAndReturn);\n    __privateAdd(this, _maybeAppendPause);\n    __privateAdd(this, _generateTemporaryOptionQueueItems);\n    __privateAdd(this, _updateOptions);\n    /**\n     * Based on provided strings, generate a TypeIt queue\n     * to be fired for each character in the string.\n     */\n    __privateAdd(this, _generateQueue);\n    __privateAdd(this, _prependHardcodedStrings);\n    /**\n     * Provided it's a non-form element and the options is provided,\n     * set up the cursor element for the animation.\n     */\n    __privateAdd(this, _setUpCursor);\n    __privateAdd(this, _addSplitPause);\n    __privateAdd(this, _type);\n    __privateAdd(this, _delete);\n    __privateAdd(this, _removeNode);\n    __privateAdd(this, _getPace);\n    __privateAdd(this, _derivedCursorPosition);\n    __privateAdd(this, _isInput);\n    __privateAdd(this, _shouldRenderCursor);\n    __privateAdd(this, _allChars);\n    __publicField(this, \"element\");\n    __publicField(this, \"timeouts\");\n    __publicField(this, \"cursorPosition\");\n    __publicField(this, \"predictedCursorPosition\");\n    __publicField(this, \"statuses\", {\n      started: false,\n      completed: false,\n      frozen: false,\n      destroyed: false\n    });\n    __publicField(this, \"opts\");\n    __publicField(this, \"id\");\n    __publicField(this, \"queue\");\n    __publicField(this, \"cursor\");\n    __publicField(this, \"unfreeze\", () => {\n    });\n    __publicField(this, \"is\", function(key) {\n      return this.statuses[key];\n    });\n    __privateAdd(this, _buildOptions, (options) => {\n      options.cursor = processCursorOptions(\n        options.cursor ?? DEFAULT_OPTIONS.cursor\n      );\n      this.opts.strings = __privateMethod(this, _prependHardcodedStrings, prependHardcodedStrings_fn).call(this, asArray(this.opts.strings));\n      this.opts = merge(this.opts, {\n        html: !__privateGet(this, _isInput, isInput_get) && this.opts.html,\n        nextStringDelay: calculateDelay(this.opts.nextStringDelay),\n        loopDelay: calculateDelay(this.opts.loopDelay)\n      });\n    });\n    this.opts = merge(DEFAULT_OPTIONS, options);\n    this.element = selectorToElement(element);\n    this.timeouts = [];\n    this.cursorPosition = 0;\n    this.unfreeze = () => {\n    };\n    this.predictedCursorPosition = null;\n    this.statuses = merge({}, DEFAULT_STATUSES);\n    this.id = generateHash();\n    this.queue = Queue([{ delay: this.opts.startDelay }]);\n    __privateGet(this, _buildOptions).call(this, options);\n    this.cursor = __privateMethod(this, _setUpCursor, setUpCursor_fn).call(this);\n    this.element.dataset.typeitId = this.id;\n    appendStyleBlock(PLACEHOLDER_CSS);\n    if (this.opts.strings.length) {\n      __privateMethod(this, _generateQueue, generateQueue_fn).call(this);\n    }\n  }\n  /**\n   * Can only be called once.\n   */\n  go() {\n    if (this.statuses.started) {\n      return this;\n    }\n    __privateMethod(this, _attachCursor, attachCursor_fn).call(this);\n    if (!this.opts.waitUntilVisible) {\n      __privateMethod(this, _fire, fire_fn).call(this);\n      return this;\n    }\n    fireWhenVisible(this.element, __privateMethod(this, _fire, fire_fn).bind(this));\n    return this;\n  }\n  destroy(shouldRemoveCursor = true) {\n    this.timeouts = destroyTimeouts(this.timeouts);\n    handleFunctionalArg(shouldRemoveCursor) && this.cursor && __privateMethod(this, _removeNode, removeNode_fn).call(this, this.cursor);\n    this.statuses.destroyed = true;\n  }\n  reset(rebuild) {\n    !this.is(\"destroyed\") && this.destroy();\n    if (rebuild) {\n      this.queue.wipe();\n      rebuild(this);\n    } else {\n      this.queue.reset();\n    }\n    this.cursorPosition = 0;\n    for (let property in this.statuses) {\n      this.statuses[property] = false;\n    }\n    this.element[__privateMethod(this, _elementIsInput, elementIsInput_fn).call(this) ? \"value\" : \"innerHTML\"] = \"\";\n    return this;\n  }\n  type(string, actionOpts = {}) {\n    string = handleFunctionalArg(string);\n    let { instant } = actionOpts;\n    let bookEndQueueItems = __privateMethod(this, _generateTemporaryOptionQueueItems, generateTemporaryOptionQueueItems_fn).call(this, actionOpts);\n    let chars = maybeChunkStringAsHtml(string, this.opts.html);\n    let charsAsQueueItems = chars.map((char) => {\n      return {\n        func: () => __privateMethod(this, _type, type_fn).call(this, char),\n        char,\n        delay: instant || isNonVoidElement(char) ? 0 : __privateMethod(this, _getPace, getPace_fn).call(this),\n        typeable: char.nodeType === Node.TEXT_NODE\n      };\n    });\n    let itemsToQueue = [\n      bookEndQueueItems[0],\n      { func: async () => await this.opts.beforeString(string, this) },\n      ...charsAsQueueItems,\n      { func: async () => await this.opts.afterString(string, this) },\n      bookEndQueueItems[1]\n    ];\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, itemsToQueue, actionOpts);\n  }\n  break(actionOpts = {}) {\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, {\n      func: () => __privateMethod(this, _type, type_fn).call(this, createElement(\"BR\")),\n      typeable: true\n    }, actionOpts);\n  }\n  move(movementArg, actionOpts = {}) {\n    movementArg = handleFunctionalArg(movementArg);\n    let bookEndQueueItems = __privateMethod(this, _generateTemporaryOptionQueueItems, generateTemporaryOptionQueueItems_fn).call(this, actionOpts);\n    let { instant, to } = actionOpts;\n    let numberOfSteps = countStepsToSelector({\n      queueItems: this.queue.getTypeable(),\n      selector: movementArg === null ? \"\" : movementArg,\n      to,\n      cursorPosition: __privateGet(this, _derivedCursorPosition, derivedCursorPosition_get)\n    });\n    let directionalStep = numberOfSteps < 0 ? -1 : 1;\n    this.predictedCursorPosition = __privateGet(this, _derivedCursorPosition, derivedCursorPosition_get) + numberOfSteps;\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, [\n      bookEndQueueItems[0],\n      ...duplicate(\n        {\n          func: () => __privateMethod(this, _move, move_fn).call(this, directionalStep),\n          delay: instant ? 0 : __privateMethod(this, _getPace, getPace_fn).call(this),\n          cursorable: true\n        },\n        Math.abs(numberOfSteps)\n      ),\n      bookEndQueueItems[1]\n    ], actionOpts);\n  }\n  exec(func, actionOpts = {}) {\n    let bookEndQueueItems = __privateMethod(this, _generateTemporaryOptionQueueItems, generateTemporaryOptionQueueItems_fn).call(this, actionOpts);\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, [bookEndQueueItems[0], { func: () => func(this) }, bookEndQueueItems[1]], actionOpts);\n  }\n  options(opts, actionOpts = {}) {\n    opts = handleFunctionalArg(opts);\n    __privateMethod(this, _updateOptions, updateOptions_fn).call(this, opts);\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, {}, actionOpts);\n  }\n  pause(milliseconds, actionOpts = {}) {\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, { delay: handleFunctionalArg(milliseconds) }, actionOpts);\n  }\n  delete(numCharacters = null, actionOpts = {}) {\n    numCharacters = handleFunctionalArg(numCharacters);\n    let bookEndQueueItems = __privateMethod(this, _generateTemporaryOptionQueueItems, generateTemporaryOptionQueueItems_fn).call(this, actionOpts);\n    let num = numCharacters;\n    let { instant, to } = actionOpts;\n    let typeableQueueItems = this.queue.getTypeable();\n    let rounds = (() => {\n      if (num === null) {\n        return typeableQueueItems.length;\n      }\n      if (isNumber(num)) {\n        return num;\n      }\n      return countStepsToSelector({\n        queueItems: typeableQueueItems,\n        selector: num,\n        cursorPosition: __privateGet(this, _derivedCursorPosition, derivedCursorPosition_get),\n        to\n      });\n    })();\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, [\n      bookEndQueueItems[0],\n      ...duplicate(\n        {\n          func: __privateMethod(this, _delete, delete_fn).bind(this),\n          delay: instant ? 0 : __privateMethod(this, _getPace, getPace_fn).call(this, 1),\n          deletable: true\n        },\n        rounds\n      ),\n      bookEndQueueItems[1]\n    ], actionOpts);\n  }\n  freeze() {\n    this.statuses.frozen = true;\n  }\n  /**\n   * Like `.go()`, but more... \"off the grid.\"\n   *\n   * - won't trigger `afterComplete` callback\n   * - items won't be replayed after `.reset()`\n   *\n   * When called, all non-done items will be \"flushed\" --\n   * that is, executed, but not remembered.\n   */\n  flush(cb = () => {\n  }) {\n    __privateMethod(this, _attachCursor, attachCursor_fn).call(this);\n    __privateMethod(this, _fire, fire_fn).call(this, false).then(cb);\n    return this;\n  }\n  getQueue() {\n    return this.queue;\n  }\n  getOptions() {\n    return this.opts;\n  }\n  updateOptions(options) {\n    return __privateMethod(this, _updateOptions, updateOptions_fn).call(this, options);\n  }\n  getElement() {\n    return this.element;\n  }\n  empty(actionOpts = {}) {\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, { func: __privateMethod(this, _empty, empty_fn).bind(this) }, actionOpts);\n  }\n}, _empty = new WeakSet(), empty_fn = async function() {\n  if (__privateMethod(this, _elementIsInput, elementIsInput_fn).call(this)) {\n    this.element.value = \"\";\n    return;\n  }\n  __privateGet(this, _allChars, allChars_get).forEach(__privateMethod(this, _removeNode, removeNode_fn).bind(this));\n  return;\n}, _fire = new WeakSet(), fire_fn = async function(remember = true) {\n  this.statuses.started = true;\n  let cleanUp = (qKey) => {\n    this.queue.done(qKey, !remember);\n  };\n  try {\n    let queueItems = [...this.queue.getQueue()];\n    for (let index = 0; index < queueItems.length; index++) {\n      let [queueKey, queueItem] = queueItems[index];\n      if (queueItem.done)\n        continue;\n      if (!queueItem.deletable || queueItem.deletable && __privateGet(this, _allChars, allChars_get).length) {\n        let newIndex = await __privateMethod(this, _fireItemWithContext, fireItemWithContext_fn).call(this, index, queueItems);\n        Array(newIndex - index).fill(index + 1).map((x, y) => x + y).forEach((i) => {\n          let [key] = queueItems[i];\n          cleanUp(key);\n        });\n        index = newIndex;\n      }\n      cleanUp(queueKey);\n    }\n    if (!remember) {\n      return this;\n    }\n    this.statuses.completed = true;\n    await this.opts.afterComplete(this);\n    if (!this.opts.loop) {\n      throw \"\";\n    }\n    let delay = this.opts.loopDelay;\n    __privateMethod(this, _wait, wait_fn).call(this, async () => {\n      await __privateMethod(this, _prepLoop, prepLoop_fn).call(this, delay[0]);\n      __privateMethod(this, _fire, fire_fn).call(this);\n    }, delay[1]);\n  } catch (e) {\n  }\n  return this;\n}, _move = new WeakSet(), move_fn = async function(step) {\n  this.cursorPosition = updateCursorPosition(\n    step,\n    this.cursorPosition,\n    __privateGet(this, _allChars, allChars_get)\n  );\n  repositionCursor(this.element, __privateGet(this, _allChars, allChars_get), this.cursorPosition);\n}, _prepLoop = new WeakSet(), prepLoop_fn = async function(delay) {\n  let derivedCursorPosition = __privateGet(this, _derivedCursorPosition, derivedCursorPosition_get);\n  derivedCursorPosition && await __privateMethod(this, _move, move_fn).call(this, { value: derivedCursorPosition });\n  let queueItems = __privateGet(this, _allChars, allChars_get).map((c) => {\n    return [\n      Symbol(),\n      {\n        func: __privateMethod(this, _delete, delete_fn).bind(this),\n        delay: __privateMethod(this, _getPace, getPace_fn).call(this, 1),\n        deletable: true,\n        shouldPauseCursor: () => true\n      }\n    ];\n  });\n  for (let index = 0; index < queueItems.length; index++) {\n    await __privateMethod(this, _fireItemWithContext, fireItemWithContext_fn).call(this, index, queueItems);\n  }\n  this.queue.reset();\n  this.queue.set(0, { delay });\n}, _fireItemWithContext = new WeakSet(), fireItemWithContext_fn = function(index, queueItems) {\n  return fireItem({\n    index,\n    queueItems,\n    wait: __privateMethod(this, _wait, wait_fn).bind(this),\n    cursor: this.cursor,\n    cursorOptions: this.opts.cursor\n  });\n}, _wait = new WeakSet(), wait_fn = async function(callback, delay, silent = false) {\n  if (this.statuses.frozen) {\n    await new Promise((resolve) => {\n      this.unfreeze = () => {\n        this.statuses.frozen = false;\n        resolve();\n      };\n    });\n  }\n  silent || await this.opts.beforeStep(this);\n  await wait(callback, delay, this.timeouts);\n  silent || await this.opts.afterStep(this);\n}, _attachCursor = new WeakSet(), attachCursor_fn = async function() {\n  !__privateMethod(this, _elementIsInput, elementIsInput_fn).call(this) && this.cursor && this.element.appendChild(this.cursor);\n  if (__privateGet(this, _shouldRenderCursor, shouldRenderCursor_get)) {\n    setCursorStyles(this.id, this.element);\n    this.cursor.dataset.tiAnimationId = this.id;\n    let { animation } = this.opts.cursor;\n    let { frames, options } = animation;\n    setCursorAnimation({\n      frames,\n      cursor: this.cursor,\n      options: {\n        duration: this.opts.cursorSpeed,\n        ...options\n      }\n    });\n  }\n}, _elementIsInput = new WeakSet(), elementIsInput_fn = function() {\n  return isInput(this.element);\n}, _queueAndReturn = new WeakSet(), queueAndReturn_fn = function(steps, opts) {\n  this.queue.add(steps);\n  __privateMethod(this, _maybeAppendPause, maybeAppendPause_fn).call(this, opts);\n  return this;\n}, _maybeAppendPause = new WeakSet(), maybeAppendPause_fn = function(opts = {}) {\n  let delay = opts.delay;\n  delay && this.queue.add({ delay });\n}, _generateTemporaryOptionQueueItems = new WeakSet(), generateTemporaryOptionQueueItems_fn = function(newOptions = {}) {\n  return [\n    { func: () => __privateMethod(this, _updateOptions, updateOptions_fn).call(this, newOptions) },\n    { func: () => __privateMethod(this, _updateOptions, updateOptions_fn).call(this, this.opts) }\n  ];\n}, _updateOptions = new WeakSet(), updateOptions_fn = async function(opts) {\n  this.opts = merge(this.opts, opts);\n}, _generateQueue = new WeakSet(), generateQueue_fn = function() {\n  let strings = this.opts.strings.filter((string) => !!string);\n  strings.forEach((string, index) => {\n    this.type(string);\n    if (index + 1 === strings.length) {\n      return;\n    }\n    let splitItems = this.opts.breakLines ? [{ func: () => __privateMethod(this, _type, type_fn).call(this, createElement(\"BR\")), typeable: true }] : duplicate(\n      {\n        func: __privateMethod(this, _delete, delete_fn).bind(this),\n        delay: __privateMethod(this, _getPace, getPace_fn).call(this, 1)\n      },\n      this.queue.getTypeable().length\n    );\n    __privateMethod(this, _addSplitPause, addSplitPause_fn).call(this, splitItems);\n  });\n}, _buildOptions = new WeakMap(), _prependHardcodedStrings = new WeakSet(), prependHardcodedStrings_fn = function(strings) {\n  let existingMarkup = this.element.innerHTML;\n  if (!existingMarkup) {\n    return strings;\n  }\n  this.element.innerHTML = \"\";\n  if (this.opts.startDelete) {\n    this.element.innerHTML = existingMarkup;\n    expandTextNodes(this.element);\n    __privateMethod(this, _addSplitPause, addSplitPause_fn).call(this, duplicate(\n      {\n        func: __privateMethod(this, _delete, delete_fn).bind(this),\n        delay: __privateMethod(this, _getPace, getPace_fn).call(this, 1),\n        deletable: true\n      },\n      __privateGet(this, _allChars, allChars_get).length\n    ));\n    return strings;\n  }\n  return splitOnBreak(existingMarkup).concat(strings);\n}, _setUpCursor = new WeakSet(), setUpCursor_fn = function() {\n  if (__privateGet(this, _isInput, isInput_get)) {\n    return null;\n  }\n  let cursor = createElement(\"span\");\n  cursor.className = CURSOR_CLASS;\n  if (!__privateGet(this, _shouldRenderCursor, shouldRenderCursor_get)) {\n    cursor.style.visibility = \"hidden\";\n    return cursor;\n  }\n  cursor.innerHTML = getParsedBody(this.opts.cursorChar).innerHTML;\n  return cursor;\n}, _addSplitPause = new WeakSet(), addSplitPause_fn = function(items) {\n  let delay = this.opts.nextStringDelay;\n  this.queue.add([{ delay: delay[0] }, ...items, { delay: delay[1] }]);\n}, _type = new WeakSet(), type_fn = function(char) {\n  insertIntoElement(this.element, char);\n}, _delete = new WeakSet(), delete_fn = function() {\n  if (!__privateGet(this, _allChars, allChars_get).length)\n    return;\n  if (__privateGet(this, _isInput, isInput_get)) {\n    this.element.value = this.element.value.slice(0, -1);\n  } else {\n    __privateMethod(this, _removeNode, removeNode_fn).call(this, __privateGet(this, _allChars, allChars_get)[this.cursorPosition]);\n  }\n}, _removeNode = new WeakSet(), removeNode_fn = function(node) {\n  removeNode(node, this.element);\n}, _getPace = new WeakSet(), getPace_fn = function(index = 0) {\n  return calculatePace(this.opts)[index];\n}, _derivedCursorPosition = new WeakSet(), derivedCursorPosition_get = function() {\n  return this.predictedCursorPosition ?? this.cursorPosition;\n}, _isInput = new WeakSet(), isInput_get = function() {\n  return isInput(this.element);\n}, _shouldRenderCursor = new WeakSet(), shouldRenderCursor_get = function() {\n  return !!this.opts.cursor && !__privateGet(this, _isInput, isInput_get);\n}, _allChars = new WeakSet(), allChars_get = function() {\n  return getAllChars(this.element);\n}, _a);\nconst DynamicElementComponent = forwardRef((props, ref) => {\n  const { as: As } = props;\n  return /* @__PURE__ */ React.createElement(As, { ref, ...props });\n});\nconst defaultPropOptions = {};\nconst TypeIt = ({\n  as = \"span\",\n  options = defaultPropOptions,\n  children = null,\n  getBeforeInit = (instance) => instance,\n  getAfterInit = (instance) => instance,\n  ...remainingProps\n}) => {\n  const elementRef = useRef(null);\n  const instanceRef = useRef(null);\n  const [shouldShowChildren, setShouldShowChildren] = useState(true);\n  const [instanceOptions, setInstanceOptions] = useState(null);\n  function calculateOptions() {\n    const optionsClone = Object.assign({}, options);\n    if (children && elementRef.current) {\n      optionsClone.strings = elementRef.current.innerHTML;\n    }\n    setInstanceOptions(optionsClone);\n  }\n  function generateNewInstance() {\n    instanceRef.current = new TypeIt$1(elementRef.current, instanceOptions);\n    instanceRef.current = getBeforeInit(instanceRef.current);\n    instanceRef.current.go();\n    instanceRef.current = getAfterInit(instanceRef.current);\n  }\n  useEffect(() => {\n    calculateOptions();\n    setShouldShowChildren(false);\n  }, [options]);\n  useEffect(() => {\n    var _a2;\n    if (!instanceOptions)\n      return;\n    ((_a2 = instanceRef.current) == null ? void 0 : _a2.updateOptions(instanceOptions)) || generateNewInstance();\n  }, [instanceOptions]);\n  useEffect(() => {\n    return () => {\n      var _a2;\n      return (_a2 = instanceRef.current) == null ? void 0 : _a2.destroy();\n    };\n  }, []);\n  return /* @__PURE__ */ React.createElement(\n    DynamicElementComponent,\n    {\n      ref: elementRef,\n      as,\n      children: shouldShowChildren ? children : null,\n      style: { opacity: shouldShowChildren ? 0 : 1 },\n      ...remainingProps\n    }\n  );\n};\nexport {\n  TypeIt as default\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}